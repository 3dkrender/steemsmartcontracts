const SHA256 = require('crypto-js/sha256');
const enchex = require('crypto-js/enc-hex');
const { Base64 } = require('js-base64');
const { VM, VMScript } = require('vm2');
const BigNumber = require('bignumber.js');
const validator = require('validator');
const seedrandom = require('seedrandom');

const DB_PLUGIN_NAME = require('../plugins/Database.constants').PLUGIN_NAME;
const DB_PLUGIN_ACTIONS = require('../plugins/Database.constants').PLUGIN_ACTIONS;

const RESERVED_CONTRACT_NAMES = ['contract', 'blockProduction', 'null'];
const RESERVED_ACTIONS = ['createSSC'];

class SmartContracts {
  // deploy the smart contract to the blockchain and initialize the database if needed
  static async deploySmartContract(
    ipc, transaction, blockNumber, timestamp, refSteemBlockId, prevRefSteemBlockId, jsVMTimeout,
  ) {
    try {
      const { transactionId, refSteemBlockNumber, sender } = transaction;
      const payload = JSON.parse(transaction.payload);
      const { name, params, code } = payload;

      if (name && typeof name === 'string'
        && code && typeof code === 'string') {
        // the contract name has to be a string made of letters and numbers
        if (!validator.isAlphanumeric(name)
          || RESERVED_CONTRACT_NAMES.includes(name)
          || name.length < 3
          || name.length > 50) {
          return { logs: { errors: ['invalid contract name'] } };
        }

        let existingContract = null;

        const res = await ipc.send(
          { to: DB_PLUGIN_NAME, action: DB_PLUGIN_ACTIONS.FIND_CONTRACT, payload: { name } },
        );

        existingContract = res.payload;

        let finalSender = sender;

        // allow "steemsc" to update contracts owned by "null"
        if (existingContract && finalSender === 'steemsc' && existingContract.owner === 'null') {
          finalSender = 'null';
        }

        if (existingContract && existingContract.owner !== finalSender) {
          return { logs: { errors: ['you are not allowed to update this contract'] } };
        }

        // this code template is used to manage the code of the smart contract
        // this way we keep control of what can be executed in a smart contract
        let codeTemplate = `
          RegExp.prototype.constructor = function () { };
          RegExp.prototype.exec = function () {  };
          RegExp.prototype.test = function () {  };

          let actions = {};

          ###ACTIONS###

          const execute = async function () {
            try {
              if (api.action && typeof api.action === 'string' && typeof actions[api.action] === 'function') {
                if (api.action !== 'createSSC') {
                  actions.createSSC = null;
                }
                await actions[api.action](api.payload);
                done(null);
              } else {
                done('invalid action');
              }
            } catch (error) {
              done(error);
            }
          }

          execute();
        `;

        // handle new database engine, we need to store data properly
        let finalCode = code;
        // market contract
        if (refSteemBlockNumber === 33104773) {
          finalCode = 'LyogZXNsaW50LWRpc2FibGUgbm8tYXdhaXQtaW4tbG9vcCAqLwovKiBnbG9iYWwgYWN0aW9ucywgYXBpICovCmNvbnN0IFNURUVNX1BFR0dFRF9TWU1CT0wgPSAnU1RFRU1QJzsKY29uc3QgU1RFRU1fUEVHR0VEX1NZTUJPTF9QUkVTSUNJT04gPSA4Owpjb25zdCBDT05UUkFDVF9OQU1FID0gJ21hcmtldCc7CgphY3Rpb25zLmNyZWF0ZVNTQyA9IGFzeW5jICgpID0+IHsKICBjb25zdCB0YWJsZUV4aXN0cyA9IGF3YWl0IGFwaS5kYi50YWJsZUV4aXN0cygnYnV5Qm9vaycpOwoKICBpZiAodGFibGVFeGlzdHMgPT09IGZhbHNlKSB7CiAgICBhd2FpdCBhcGkuZGIuY3JlYXRlVGFibGUoJ2J1eUJvb2snLCBbJ3N5bWJvbCcsICdhY2NvdW50JywgJ3ByaWNlJywgJ2V4cGlyYXRpb24nLCAndHhJZCddKTsKICAgIGF3YWl0IGFwaS5kYi5jcmVhdGVUYWJsZSgnc2VsbEJvb2snLCBbJ3N5bWJvbCcsICdhY2NvdW50JywgJ3ByaWNlJywgJ2V4cGlyYXRpb24nLCAndHhJZCddKTsKICAgIGF3YWl0IGFwaS5kYi5jcmVhdGVUYWJsZSgndHJhZGVzSGlzdG9yeScsIFsnc3ltYm9sJ10pOwogICAgYXdhaXQgYXBpLmRiLmNyZWF0ZVRhYmxlKCdtZXRyaWNzJywgWydzeW1ib2wnXSk7CiAgfQp9OwoKYWN0aW9ucy5jYW5jZWwgPSBhc3luYyAocGF5bG9hZCkgPT4gewogIGNvbnN0IHsgdHlwZSwgaWQsIGlzU2lnbmVkV2l0aEFjdGl2ZUtleSB9ID0gcGF5bG9hZDsKCiAgY29uc3QgdHlwZXMgPSBbJ2J1eScsICdzZWxsJ107CgogIGlmIChhcGkuYXNzZXJ0KGlzU2lnbmVkV2l0aEFjdGl2ZUtleSA9PT0gdHJ1ZSwgJ3lvdSBtdXN0IHVzZSBhIGN1c3RvbV9qc29uIHNpZ25lZCB3aXRoIHlvdXIgYWN0aXZlIGtleScpCiAgICAmJiBhcGkuYXNzZXJ0KHR5cGUgJiYgdHlwZXMuaW5jbHVkZXModHlwZSkKICAgICAgJiYgaWQsICdpbnZhbGlkIHBhcmFtcycpKSB7CiAgICBjb25zdCB0YWJsZSA9IHR5cGUgPT09ICdidXknID8gJ2J1eUJvb2snIDogJ3NlbGxCb29rJzsKCiAgICBsZXQgb3JkZXIgPSBudWxsOwogICAgLy8gZ2V0IG9yZGVyCiAgICBpZiAodHlwZW9mIGlkID09PSAnc3RyaW5nJyAmJiBpZC5sZW5ndGggPCA1MCkgewogICAgICBvcmRlciA9IGF3YWl0IGFwaS5kYi5maW5kT25lKHRhYmxlLCB7IHR4SWQ6IGlkIH0pOwogICAgfQoKICAgIGlmIChhcGkuYXNzZXJ0KG9yZGVyICE9PSBudWxsLCAnb3JkZXIgZG9lcyBub3QgZXhpc3Qgb3IgaW52YWxpZCBwYXJhbXMnKQogICAgICAmJiBvcmRlci5hY2NvdW50ID09PSBhcGkuc2VuZGVyKSB7CiAgICAgIGxldCBxdWFudGl0eTsKICAgICAgbGV0IHN5bWJvbDsKCiAgICAgIGlmICh0eXBlID09PSAnYnV5JykgewogICAgICAgIHN5bWJvbCA9IFNURUVNX1BFR0dFRF9TWU1CT0w7CiAgICAgICAgcXVhbnRpdHkgPSBvcmRlci50b2tlbnNMb2NrZWQ7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgc3ltYm9sID0gb3JkZXIuc3ltYm9sOwogICAgICAgIHF1YW50aXR5ID0gb3JkZXIucXVhbnRpdHk7CiAgICAgIH0KCiAgICAgIC8vIHVubG9jayB0b2tlbnMKICAgICAgYXdhaXQgYXBpLnRyYW5zZmVyVG9rZW5zKGFwaS5zZW5kZXIsIHN5bWJvbCwgcXVhbnRpdHksICd1c2VyJyk7CgogICAgICBhd2FpdCBhcGkuZGIucmVtb3ZlKHRhYmxlLCBvcmRlcik7CgogICAgICBpZiAodHlwZSA9PT0gJ3NlbGwnKSB7CiAgICAgICAgYXdhaXQgdXBkYXRlQXNrTWV0cmljKG9yZGVyLnN5bWJvbCk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgYXdhaXQgdXBkYXRlQmlkTWV0cmljKG9yZGVyLnN5bWJvbCk7CiAgICAgIH0KICAgIH0KICB9Cn07CgphY3Rpb25zLmJ1eSA9IGFzeW5jIChwYXlsb2FkKSA9PiB7CiAgY29uc3QgewogICAgc3ltYm9sLAogICAgcXVhbnRpdHksCiAgICBwcmljZSwKICAgIGV4cGlyYXRpb24sCiAgICBpc1NpZ25lZFdpdGhBY3RpdmVLZXksCiAgfSA9IHBheWxvYWQ7CgogIC8vIGJ1eSAocXVhbnRpdHkpIG9mIChzeW1ib2wpIGF0IChwcmljZSkoU1RFRU1fUEVHR0VEX1NZTUJPTCkgcGVyIChzeW1ib2wpCiAgaWYgKGFwaS5hc3NlcnQoaXNTaWduZWRXaXRoQWN0aXZlS2V5ID09PSB0cnVlLCAneW91IG11c3QgdXNlIGEgY3VzdG9tX2pzb24gc2lnbmVkIHdpdGggeW91ciBhY3RpdmUga2V5JykKICAgICYmIGFwaS5hc3NlcnQocHJpY2UgJiYgdHlwZW9mIHByaWNlID09PSAnc3RyaW5nJyAmJiAhYXBpLkJpZ051bWJlcihwcmljZSkuaXNOYU4oKQogICAgICAmJiBzeW1ib2wgJiYgdHlwZW9mIHN5bWJvbCA9PT0gJ3N0cmluZycgJiYgc3ltYm9sICE9PSBTVEVFTV9QRUdHRURfU1lNQk9MCiAgICAgICYmIHF1YW50aXR5ICYmIHR5cGVvZiBxdWFudGl0eSA9PT0gJ3N0cmluZycgJiYgIWFwaS5CaWdOdW1iZXIocXVhbnRpdHkpLmlzTmFOKCkKICAgICAgJiYgKGV4cGlyYXRpb24gPT09IHVuZGVmaW5lZCB8fCAoZXhwaXJhdGlvbiAmJiBOdW1iZXIuaXNJbnRlZ2VyKGV4cGlyYXRpb24pICYmIGV4cGlyYXRpb24gPiAwKSksICdpbnZhbGlkIHBhcmFtcycpCiAgKSB7CiAgICAvLyBnZXQgdGhlIHRva2VuIHBhcmFtcwogICAgY29uc3QgdG9rZW4gPSBhd2FpdCBhcGkuZGIuZmluZE9uZUluVGFibGUoJ3Rva2VucycsICd0b2tlbnMnLCB7IHN5bWJvbCB9KTsKCiAgICAvLyBwZXJmb3JtIGEgZmV3IHZlcmlmaWNhdGlvbnMKICAgIGlmIChhcGkuYXNzZXJ0KHRva2VuCiAgICAgICYmIGFwaS5CaWdOdW1iZXIocHJpY2UpLmd0KDApCiAgICAgICYmIGNvdW50RGVjaW1hbHMocHJpY2UpIDw9IFNURUVNX1BFR0dFRF9TWU1CT0xfUFJFU0lDSU9OCiAgICAgICYmIGNvdW50RGVjaW1hbHMocXVhbnRpdHkpIDw9IHRva2VuLnByZWNpc2lvbiwgJ2ludmFsaWQgcGFyYW1zJykpIHsKICAgICAgLy8gaW5pdGlhdGUgYSB0cmFuc2ZlciBmcm9tIGFwaS5zZW5kZXIgdG8gY29udHJhY3QgYmFsYW5jZQoKICAgICAgY29uc3QgbmJUb2tlbnNUb0xvY2sgPSBhcGkuQmlnTnVtYmVyKHByaWNlKQogICAgICAgIC5tdWx0aXBsaWVkQnkocXVhbnRpdHkpCiAgICAgICAgLnRvRml4ZWQoU1RFRU1fUEVHR0VEX1NZTUJPTF9QUkVTSUNJT04pOwoKICAgICAgaWYgKGFwaS5hc3NlcnQoYXBpLkJpZ051bWJlcihuYlRva2Vuc1RvTG9jaykuZ3RlKCcwLjAwMDAwMDAxJyksICdvcmRlciBjYW5ub3QgYmUgcGxhY2VkIGFzIGl0IGNhbm5vdCBiZSBmaWxsZWQnKSkgewogICAgICAgIC8vIGxvY2sgU1RFRU1fUEVHR0VEX1NZTUJPTCB0b2tlbnMKICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBhcGkuZXhlY3V0ZVNtYXJ0Q29udHJhY3QoJ3Rva2VucycsICd0cmFuc2ZlclRvQ29udHJhY3QnLCB7IHN5bWJvbDogU1RFRU1fUEVHR0VEX1NZTUJPTCwgcXVhbnRpdHk6IG5iVG9rZW5zVG9Mb2NrLCB0bzogQ09OVFJBQ1RfTkFNRSB9KTsKCiAgICAgICAgaWYgKHJlcy5lcnJvcnMgPT09IHVuZGVmaW5lZAogICAgICAgICAgJiYgcmVzLmV2ZW50cyAmJiByZXMuZXZlbnRzLmZpbmQoZWwgPT4gZWwuY29udHJhY3QgPT09ICd0b2tlbnMnICYmIGVsLmV2ZW50ID09PSAndHJhbnNmZXJUb0NvbnRyYWN0JyAmJiBlbC5kYXRhLmZyb20gPT09IGFwaS5zZW5kZXIgJiYgZWwuZGF0YS50byA9PT0gQ09OVFJBQ1RfTkFNRSAmJiBlbC5kYXRhLnF1YW50aXR5ID09PSBuYlRva2Vuc1RvTG9jayAmJiBlbC5kYXRhLnN5bWJvbCA9PT0gU1RFRU1fUEVHR0VEX1NZTUJPTCkgIT09IHVuZGVmaW5lZCkgewogICAgICAgICAgY29uc3QgdGltZXN0YW1wU2VjID0gYXBpLkJpZ051bWJlcihuZXcgRGF0ZShgJHthcGkuc3RlZW1CbG9ja1RpbWVzdGFtcH0uMDAwWmApLmdldFRpbWUoKSkKICAgICAgICAgICAgLmRpdmlkZWRCeSgxMDAwKQogICAgICAgICAgICAudG9OdW1iZXIoKTsKCiAgICAgICAgICAvLyBvcmRlcgogICAgICAgICAgY29uc3Qgb3JkZXIgPSB7fTsKCiAgICAgICAgICBvcmRlci50eElkID0gYXBpLnRyYW5zYWN0aW9uSWQ7CiAgICAgICAgICBvcmRlci50aW1lc3RhbXAgPSB0aW1lc3RhbXBTZWM7CiAgICAgICAgICBvcmRlci5hY2NvdW50ID0gYXBpLnNlbmRlcjsKICAgICAgICAgIG9yZGVyLnN5bWJvbCA9IHN5bWJvbDsKICAgICAgICAgIG9yZGVyLnF1YW50aXR5ID0gYXBpLkJpZ051bWJlcihxdWFudGl0eSkudG9GaXhlZCh0b2tlbi5wcmVjaXNpb24pOwogICAgICAgICAgb3JkZXIucHJpY2UgPSBhcGkuQmlnTnVtYmVyKHByaWNlKS50b0ZpeGVkKFNURUVNX1BFR0dFRF9TWU1CT0xfUFJFU0lDSU9OKTsKICAgICAgICAgIG9yZGVyLnRva2Vuc0xvY2tlZCA9IG5iVG9rZW5zVG9Mb2NrOwogICAgICAgICAgb3JkZXIuZXhwaXJhdGlvbiA9IGV4cGlyYXRpb24gPT09IHVuZGVmaW5lZCB8fCBleHBpcmF0aW9uID4gMjU5MjAwMAogICAgICAgICAgICA/IHRpbWVzdGFtcFNlYyArIDI1OTIwMDAKICAgICAgICAgICAgOiB0aW1lc3RhbXBTZWMgKyBleHBpcmF0aW9uOwoKICAgICAgICAgIGNvbnN0IG9yZGVySW5EYiA9IGF3YWl0IGFwaS5kYi5pbnNlcnQoJ2J1eUJvb2snLCBvcmRlcik7CgogICAgICAgICAgYXdhaXQgZmluZE1hdGNoaW5nU2VsbE9yZGVycyhvcmRlckluRGIsIHRva2VuLnByZWNpc2lvbik7CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgfQp9OwoKYWN0aW9ucy5zZWxsID0gYXN5bmMgKHBheWxvYWQpID0+IHsKICBjb25zdCB7CiAgICBzeW1ib2wsCiAgICBxdWFudGl0eSwKICAgIHByaWNlLAogICAgZXhwaXJhdGlvbiwKICAgIGlzU2lnbmVkV2l0aEFjdGl2ZUtleSwKICB9ID0gcGF5bG9hZDsKICAvLyBzZWxsIChxdWFudGl0eSkgb2YgKHN5bWJvbCkgYXQgKHByaWNlKShTVEVFTV9QRUdHRURfU1lNQk9MKSBwZXIgKHN5bWJvbCkKICBpZiAoYXBpLmFzc2VydChpc1NpZ25lZFdpdGhBY3RpdmVLZXkgPT09IHRydWUsICd5b3UgbXVzdCB1c2UgYSBjdXN0b21fanNvbiBzaWduZWQgd2l0aCB5b3VyIGFjdGl2ZSBrZXknKQogICAgJiYgYXBpLmFzc2VydChwcmljZSAmJiB0eXBlb2YgcHJpY2UgPT09ICdzdHJpbmcnICYmICFhcGkuQmlnTnVtYmVyKHByaWNlKS5pc05hTigpCiAgICAgICYmIHN5bWJvbCAmJiB0eXBlb2Ygc3ltYm9sID09PSAnc3RyaW5nJyAmJiBzeW1ib2wgIT09IFNURUVNX1BFR0dFRF9TWU1CT0wKICAgICAgJiYgcXVhbnRpdHkgJiYgdHlwZW9mIHF1YW50aXR5ID09PSAnc3RyaW5nJyAmJiAhYXBpLkJpZ051bWJlcihxdWFudGl0eSkuaXNOYU4oKQogICAgICAmJiAoZXhwaXJhdGlvbiA9PT0gdW5kZWZpbmVkIHx8IChleHBpcmF0aW9uICYmIE51bWJlci5pc0ludGVnZXIoZXhwaXJhdGlvbikgJiYgZXhwaXJhdGlvbiA+IDApKSwgJ2ludmFsaWQgcGFyYW1zJykpIHsKICAgIC8vIGdldCB0aGUgdG9rZW4gcGFyYW1zCiAgICBjb25zdCB0b2tlbiA9IGF3YWl0IGFwaS5kYi5maW5kT25lSW5UYWJsZSgndG9rZW5zJywgJ3Rva2VucycsIHsgc3ltYm9sIH0pOwoKICAgIC8vIHBlcmZvcm0gYSBmZXcgdmVyaWZpY2F0aW9ucwogICAgaWYgKGFwaS5hc3NlcnQodG9rZW4KICAgICAgJiYgYXBpLkJpZ051bWJlcihwcmljZSkuZ3QoMCkKICAgICAgJiYgY291bnREZWNpbWFscyhwcmljZSkgPD0gU1RFRU1fUEVHR0VEX1NZTUJPTF9QUkVTSUNJT04KICAgICAgJiYgY291bnREZWNpbWFscyhxdWFudGl0eSkgPD0gdG9rZW4ucHJlY2lzaW9uLCAnaW52YWxpZCBwYXJhbXMnKSkgewogICAgICBjb25zdCBuYlRva2Vuc1RvRmlsbE9yZGVyID0gYXBpLkJpZ051bWJlcihwcmljZSkKICAgICAgICAubXVsdGlwbGllZEJ5KHF1YW50aXR5KQogICAgICAgIC50b0ZpeGVkKFNURUVNX1BFR0dFRF9TWU1CT0xfUFJFU0lDSU9OKTsKCiAgICAgIGlmIChhcGkuYXNzZXJ0KGFwaS5CaWdOdW1iZXIobmJUb2tlbnNUb0ZpbGxPcmRlcikuZ3RlKCcwLjAwMDAwMDAxJyksICdvcmRlciBjYW5ub3QgYmUgcGxhY2VkIGFzIGl0IGNhbm5vdCBiZSBmaWxsZWQnKSkgewogICAgICAgIC8vIGluaXRpYXRlIGEgdHJhbnNmZXIgZnJvbSBhcGkuc2VuZGVyIHRvIGNvbnRyYWN0IGJhbGFuY2UKICAgICAgICAvLyBsb2NrIHN5bWJvbCB0b2tlbnMKICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBhcGkuZXhlY3V0ZVNtYXJ0Q29udHJhY3QoJ3Rva2VucycsICd0cmFuc2ZlclRvQ29udHJhY3QnLCB7IHN5bWJvbCwgcXVhbnRpdHksIHRvOiBDT05UUkFDVF9OQU1FIH0pOwoKICAgICAgICBpZiAocmVzLmVycm9ycyA9PT0gdW5kZWZpbmVkCiAgICAgICAgICAmJiByZXMuZXZlbnRzICYmIHJlcy5ldmVudHMuZmluZChlbCA9PiBlbC5jb250cmFjdCA9PT0gJ3Rva2VucycgJiYgZWwuZXZlbnQgPT09ICd0cmFuc2ZlclRvQ29udHJhY3QnICYmIGVsLmRhdGEuZnJvbSA9PT0gYXBpLnNlbmRlciAmJiBlbC5kYXRhLnRvID09PSBDT05UUkFDVF9OQU1FICYmIGVsLmRhdGEucXVhbnRpdHkgPT09IHF1YW50aXR5ICYmIGVsLmRhdGEuc3ltYm9sID09PSBzeW1ib2wpICE9PSB1bmRlZmluZWQpIHsKICAgICAgICAgIGNvbnN0IHRpbWVzdGFtcFNlYyA9IGFwaS5CaWdOdW1iZXIobmV3IERhdGUoYCR7YXBpLnN0ZWVtQmxvY2tUaW1lc3RhbXB9LjAwMFpgKS5nZXRUaW1lKCkpCiAgICAgICAgICAgIC5kaXZpZGVkQnkoMTAwMCkKICAgICAgICAgICAgLnRvTnVtYmVyKCk7CgogICAgICAgICAgLy8gb3JkZXIKICAgICAgICAgIGNvbnN0IG9yZGVyID0ge307CgogICAgICAgICAgb3JkZXIudHhJZCA9IGFwaS50cmFuc2FjdGlvbklkOwogICAgICAgICAgb3JkZXIudGltZXN0YW1wID0gdGltZXN0YW1wU2VjOwogICAgICAgICAgb3JkZXIuYWNjb3VudCA9IGFwaS5zZW5kZXI7CiAgICAgICAgICBvcmRlci5zeW1ib2wgPSBzeW1ib2w7CiAgICAgICAgICBvcmRlci5xdWFudGl0eSA9IGFwaS5CaWdOdW1iZXIocXVhbnRpdHkpLnRvRml4ZWQodG9rZW4ucHJlY2lzaW9uKTsKICAgICAgICAgIG9yZGVyLnByaWNlID0gYXBpLkJpZ051bWJlcihwcmljZSkudG9GaXhlZChTVEVFTV9QRUdHRURfU1lNQk9MX1BSRVNJQ0lPTik7CiAgICAgICAgICBvcmRlci5leHBpcmF0aW9uID0gZXhwaXJhdGlvbiA9PT0gdW5kZWZpbmVkIHx8IGV4cGlyYXRpb24gPiAyNTkyMDAwCiAgICAgICAgICAgID8gdGltZXN0YW1wU2VjICsgMjU5MjAwMAogICAgICAgICAgICA6IHRpbWVzdGFtcFNlYyArIGV4cGlyYXRpb247CgogICAgICAgICAgY29uc3Qgb3JkZXJJbkRiID0gYXdhaXQgYXBpLmRiLmluc2VydCgnc2VsbEJvb2snLCBvcmRlcik7CgogICAgICAgICAgYXdhaXQgZmluZE1hdGNoaW5nQnV5T3JkZXJzKG9yZGVySW5EYiwgdG9rZW4ucHJlY2lzaW9uKTsKICAgICAgICB9CiAgICAgIH0KICAgIH0KICB9Cn07Cgpjb25zdCBmaW5kTWF0Y2hpbmdTZWxsT3JkZXJzID0gYXN5bmMgKG9yZGVyLCB0b2tlblByZWNpc2lvbikgPT4gewogIGNvbnN0IHsKICAgIGFjY291bnQsCiAgICBzeW1ib2wsCiAgICBwcmljZSwKICB9ID0gb3JkZXI7CgogIGNvbnN0IGJ1eU9yZGVyID0gb3JkZXI7CiAgbGV0IG9mZnNldCA9IDA7CiAgbGV0IHZvbHVtZVRyYWRlZCA9IDA7CgogIGF3YWl0IHJlbW92ZUV4cGlyZWRPcmRlcnMoJ3NlbGxCb29rJyk7CgogIC8vIGdldCB0aGUgb3JkZXJzIHRoYXQgbWF0Y2ggdGhlIHN5bWJvbCBhbmQgdGhlIHByaWNlCiAgbGV0IHNlbGxPcmRlckJvb2sgPSBhd2FpdCBhcGkuZGIuZmluZCgnc2VsbEJvb2snLCB7CiAgICBzeW1ib2wsCiAgICBwcmljZTogewogICAgICAkbHRlOiBwcmljZSwKICAgIH0sCiAgfSwgMTAwMCwgb2Zmc2V0LAogIFsKICAgIHsgaW5kZXg6ICdwcmljZScsIGRlc2NlbmRpbmc6IGZhbHNlIH0sCiAgICB7IGluZGV4OiAnJGxva2knLCBkZXNjZW5kaW5nOiBmYWxzZSB9LAogIF0pOwoKICBkbyB7CiAgICBjb25zdCBuYk9yZGVycyA9IHNlbGxPcmRlckJvb2subGVuZ3RoOwogICAgbGV0IGluYyA9IDA7CgogICAgd2hpbGUgKGluYyA8IG5iT3JkZXJzICYmIGFwaS5CaWdOdW1iZXIoYnV5T3JkZXIucXVhbnRpdHkpLmd0KDApKSB7CiAgICAgIGNvbnN0IHNlbGxPcmRlciA9IHNlbGxPcmRlckJvb2tbaW5jXTsKICAgICAgaWYgKGFwaS5CaWdOdW1iZXIoYnV5T3JkZXIucXVhbnRpdHkpLmx0ZShzZWxsT3JkZXIucXVhbnRpdHkpKSB7CiAgICAgICAgbGV0IHF0eVRva2Vuc1RvU2VuZCA9IGFwaS5CaWdOdW1iZXIoc2VsbE9yZGVyLnByaWNlKQogICAgICAgICAgLm11bHRpcGxpZWRCeShidXlPcmRlci5xdWFudGl0eSkKICAgICAgICAgIC50b0ZpeGVkKFNURUVNX1BFR0dFRF9TWU1CT0xfUFJFU0lDSU9OKTsKCiAgICAgICAgaWYgKGFwaS5CaWdOdW1iZXIocXR5VG9rZW5zVG9TZW5kKS5ndChidXlPcmRlci50b2tlbnNMb2NrZWQpKSB7CiAgICAgICAgICBxdHlUb2tlbnNUb1NlbmQgPSBhcGkuQmlnTnVtYmVyKHNlbGxPcmRlci5wcmljZSkKICAgICAgICAgICAgLm11bHRpcGxpZWRCeShidXlPcmRlci5xdWFudGl0eSkKICAgICAgICAgICAgLnRvRml4ZWQoU1RFRU1fUEVHR0VEX1NZTUJPTF9QUkVTSUNJT04sIGFwaS5CaWdOdW1iZXIuUk9VTkRfRE9XTik7CiAgICAgICAgfQoKICAgICAgICBpZiAoYXBpLmFzc2VydChhcGkuQmlnTnVtYmVyKHF0eVRva2Vuc1RvU2VuZCkuZ3QoMCkKICAgICAgICAgICYmIGFwaS5CaWdOdW1iZXIoYnV5T3JkZXIucXVhbnRpdHkpLmd0KDApLCAndGhlIG9yZGVyIGNhbm5vdCBiZSBmaWxsZWQnKSkgewogICAgICAgICAgLy8gdHJhbnNmZXIgdGhlIHRva2VucyB0byB0aGUgYnV5ZXIKICAgICAgICAgIGxldCByZXMgPSBhd2FpdCBhcGkudHJhbnNmZXJUb2tlbnMoYWNjb3VudCwgc3ltYm9sLCBidXlPcmRlci5xdWFudGl0eSwgJ3VzZXInKTsKCiAgICAgICAgICBpZiAocmVzLmVycm9ycykgewogICAgICAgICAgICBhcGkuZGVidWcocmVzLmVycm9ycyk7CiAgICAgICAgICAgIGFwaS5kZWJ1ZyhgVFhJRDogJHthcGkudHJhbnNhY3Rpb25JZH1gKTsKICAgICAgICAgICAgYXBpLmRlYnVnKGFjY291bnQpOwogICAgICAgICAgICBhcGkuZGVidWcoc3ltYm9sKTsKICAgICAgICAgICAgYXBpLmRlYnVnKGJ1eU9yZGVyLnF1YW50aXR5KTsKICAgICAgICAgIH0KCiAgICAgICAgICAvLyB0cmFuc2ZlciB0aGUgdG9rZW5zIHRvIHRoZSBzZWxsZXIKICAgICAgICAgIHJlcyA9IGF3YWl0IGFwaS50cmFuc2ZlclRva2VucyhzZWxsT3JkZXIuYWNjb3VudCwgU1RFRU1fUEVHR0VEX1NZTUJPTCwgcXR5VG9rZW5zVG9TZW5kLCAndXNlcicpOwoKICAgICAgICAgIGlmIChyZXMuZXJyb3JzKSB7CiAgICAgICAgICAgIGFwaS5kZWJ1ZyhyZXMuZXJyb3JzKTsKICAgICAgICAgICAgYXBpLmRlYnVnKGBUWElEOiAke2FwaS50cmFuc2FjdGlvbklkfWApOwogICAgICAgICAgICBhcGkuZGVidWcoc2VsbE9yZGVyLmFjY291bnQpOwogICAgICAgICAgICBhcGkuZGVidWcoU1RFRU1fUEVHR0VEX1NZTUJPTCk7CiAgICAgICAgICAgIGFwaS5kZWJ1ZyhxdHlUb2tlbnNUb1NlbmQpOwogICAgICAgICAgfQoKICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgc2VsbCBvcmRlcgogICAgICAgICAgY29uc3QgcXR5TGVmdFNlbGxPcmRlciA9IGFwaS5CaWdOdW1iZXIoc2VsbE9yZGVyLnF1YW50aXR5KQogICAgICAgICAgICAubWludXMoYnV5T3JkZXIucXVhbnRpdHkpCiAgICAgICAgICAgIC50b0ZpeGVkKHRva2VuUHJlY2lzaW9uKTsKICAgICAgICAgIGNvbnN0IG5iVG9rZW5zVG9GaWxsT3JkZXIgPSBhcGkuQmlnTnVtYmVyKHNlbGxPcmRlci5wcmljZSkKICAgICAgICAgICAgLm11bHRpcGxpZWRCeShxdHlMZWZ0U2VsbE9yZGVyKQogICAgICAgICAgICAudG9GaXhlZChTVEVFTV9QRUdHRURfU1lNQk9MX1BSRVNJQ0lPTik7CgogICAgICAgICAgaWYgKGFwaS5CaWdOdW1iZXIocXR5TGVmdFNlbGxPcmRlcikuZ3QoMCkKICAgICAgICAgICAgJiYgKGFwaS5CaWdOdW1iZXIobmJUb2tlbnNUb0ZpbGxPcmRlcikuZ3RlKCcwLjAwMDAwMDAxJykpKSB7CiAgICAgICAgICAgIHNlbGxPcmRlci5xdWFudGl0eSA9IHF0eUxlZnRTZWxsT3JkZXI7CgogICAgICAgICAgICBhd2FpdCBhcGkuZGIudXBkYXRlKCdzZWxsQm9vaycsIHNlbGxPcmRlcik7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBpZiAoYXBpLkJpZ051bWJlcihxdHlMZWZ0U2VsbE9yZGVyKS5ndCgwKSkgewogICAgICAgICAgICAgIGF3YWl0IGFwaS50cmFuc2ZlclRva2VucyhzZWxsT3JkZXIuYWNjb3VudCwgc3ltYm9sLCBxdHlMZWZ0U2VsbE9yZGVyLCAndXNlcicpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGF3YWl0IGFwaS5kYi5yZW1vdmUoJ3NlbGxCb29rJywgc2VsbE9yZGVyKTsKICAgICAgICAgIH0KCiAgICAgICAgICAvLyB1bmxvY2sgcmVtYWluaW5nIHRva2VucywgdXBkYXRlIHRoZSBxdWFudGl0eSB0byBnZXQgYW5kIHJlbW92ZSB0aGUgYnV5IG9yZGVyCiAgICAgICAgICBjb25zdCB0b2tlbnNUb1VubG9jayA9IGFwaS5CaWdOdW1iZXIoYnV5T3JkZXIudG9rZW5zTG9ja2VkKQogICAgICAgICAgICAubWludXMocXR5VG9rZW5zVG9TZW5kKQogICAgICAgICAgICAudG9GaXhlZChTVEVFTV9QRUdHRURfU1lNQk9MX1BSRVNJQ0lPTik7CgogICAgICAgICAgaWYgKGFwaS5CaWdOdW1iZXIodG9rZW5zVG9VbmxvY2spLmd0KDApKSB7CiAgICAgICAgICAgIGF3YWl0IGFwaS50cmFuc2ZlclRva2VucyhhY2NvdW50LCBTVEVFTV9QRUdHRURfU1lNQk9MLCB0b2tlbnNUb1VubG9jaywgJ3VzZXInKTsKICAgICAgICAgIH0KCiAgICAgICAgICAvLyBhZGQgdGhlIHRyYWRlIHRvIHRoZSBoaXN0b3J5CiAgICAgICAgICBhd2FpdCB1cGRhdGVUcmFkZXNIaXN0b3J5KCdidXknLCBzeW1ib2wsIGJ1eU9yZGVyLnF1YW50aXR5LCBzZWxsT3JkZXIucHJpY2UsIHF0eVRva2Vuc1RvU2VuZCk7CgogICAgICAgICAgLy8gdXBkYXRlIHRoZSB2b2x1bWUKICAgICAgICAgIHZvbHVtZVRyYWRlZCA9IGFwaS5CaWdOdW1iZXIodm9sdW1lVHJhZGVkKS5wbHVzKHF0eVRva2Vuc1RvU2VuZCk7CgogICAgICAgICAgYnV5T3JkZXIucXVhbnRpdHkgPSAnMCc7CiAgICAgICAgICBhd2FpdCBhcGkuZGIucmVtb3ZlKCdidXlCb29rJywgYnV5T3JkZXIpOwogICAgICAgIH0KICAgICAgfSBlbHNlIHsKICAgICAgICBsZXQgcXR5VG9rZW5zVG9TZW5kID0gYXBpLkJpZ051bWJlcihzZWxsT3JkZXIucHJpY2UpCiAgICAgICAgICAubXVsdGlwbGllZEJ5KHNlbGxPcmRlci5xdWFudGl0eSkKICAgICAgICAgIC50b0ZpeGVkKFNURUVNX1BFR0dFRF9TWU1CT0xfUFJFU0lDSU9OKTsKCiAgICAgICAgaWYgKGFwaS5CaWdOdW1iZXIocXR5VG9rZW5zVG9TZW5kKS5ndChidXlPcmRlci50b2tlbnNMb2NrZWQpKSB7CiAgICAgICAgICBxdHlUb2tlbnNUb1NlbmQgPSBhcGkuQmlnTnVtYmVyKHNlbGxPcmRlci5wcmljZSkKICAgICAgICAgICAgLm11bHRpcGxpZWRCeShzZWxsT3JkZXIucXVhbnRpdHkpCiAgICAgICAgICAgIC50b0ZpeGVkKFNURUVNX1BFR0dFRF9TWU1CT0xfUFJFU0lDSU9OLCBhcGkuQmlnTnVtYmVyLlJPVU5EX0RPV04pOwogICAgICAgIH0KCiAgICAgICAgaWYgKGFwaS5hc3NlcnQoYXBpLkJpZ051bWJlcihxdHlUb2tlbnNUb1NlbmQpLmd0KDApCiAgICAgICAgICAmJiBhcGkuQmlnTnVtYmVyKGJ1eU9yZGVyLnF1YW50aXR5KS5ndCgwKSwgJ3RoZSBvcmRlciBjYW5ub3QgYmUgZmlsbGVkJykpIHsKICAgICAgICAgIC8vIHRyYW5zZmVyIHRoZSB0b2tlbnMgdG8gdGhlIGJ1eWVyCiAgICAgICAgICBsZXQgcmVzID0gYXdhaXQgYXBpLnRyYW5zZmVyVG9rZW5zKGFjY291bnQsIHN5bWJvbCwgc2VsbE9yZGVyLnF1YW50aXR5LCAndXNlcicpOwoKICAgICAgICAgIGlmIChyZXMuZXJyb3JzKSB7CiAgICAgICAgICAgIGFwaS5kZWJ1ZyhyZXMuZXJyb3JzKTsKICAgICAgICAgICAgYXBpLmRlYnVnKGBUWElEOiAke2FwaS50cmFuc2FjdGlvbklkfWApOwogICAgICAgICAgICBhcGkuZGVidWcoYWNjb3VudCk7CiAgICAgICAgICAgIGFwaS5kZWJ1ZyhzeW1ib2wpOwogICAgICAgICAgICBhcGkuZGVidWcoc2VsbE9yZGVyLnF1YW50aXR5KTsKICAgICAgICAgIH0KCiAgICAgICAgICAvLyB0cmFuc2ZlciB0aGUgdG9rZW5zIHRvIHRoZSBzZWxsZXIKICAgICAgICAgIHJlcyA9IGF3YWl0IGFwaS50cmFuc2ZlclRva2VucyhzZWxsT3JkZXIuYWNjb3VudCwgU1RFRU1fUEVHR0VEX1NZTUJPTCwgcXR5VG9rZW5zVG9TZW5kLCAndXNlcicpOwoKICAgICAgICAgIGlmIChyZXMuZXJyb3JzKSB7CiAgICAgICAgICAgIGFwaS5kZWJ1ZyhyZXMuZXJyb3JzKTsKICAgICAgICAgICAgYXBpLmRlYnVnKGBUWElEOiAke2FwaS50cmFuc2FjdGlvbklkfWApOwogICAgICAgICAgICBhcGkuZGVidWcoc2VsbE9yZGVyLmFjY291bnQpOwogICAgICAgICAgICBhcGkuZGVidWcoU1RFRU1fUEVHR0VEX1NZTUJPTCk7CiAgICAgICAgICAgIGFwaS5kZWJ1ZyhxdHlUb2tlbnNUb1NlbmQpOwogICAgICAgICAgfQoKICAgICAgICAgIC8vIHJlbW92ZSB0aGUgc2VsbCBvcmRlcgogICAgICAgICAgYXdhaXQgYXBpLmRiLnJlbW92ZSgnc2VsbEJvb2snLCBzZWxsT3JkZXIpOwoKICAgICAgICAgIC8vIHVwZGF0ZSB0b2tlbnNMb2NrZWQgYW5kIHRoZSBxdWFudGl0eSB0byBnZXQKICAgICAgICAgIGJ1eU9yZGVyLnRva2Vuc0xvY2tlZCA9IGFwaS5CaWdOdW1iZXIoYnV5T3JkZXIudG9rZW5zTG9ja2VkKQogICAgICAgICAgICAubWludXMocXR5VG9rZW5zVG9TZW5kKQogICAgICAgICAgICAudG9GaXhlZChTVEVFTV9QRUdHRURfU1lNQk9MX1BSRVNJQ0lPTik7CiAgICAgICAgICBidXlPcmRlci5xdWFudGl0eSA9IGFwaS5CaWdOdW1iZXIoYnV5T3JkZXIucXVhbnRpdHkpCiAgICAgICAgICAgIC5taW51cyhzZWxsT3JkZXIucXVhbnRpdHkpCiAgICAgICAgICAgIC50b0ZpeGVkKHRva2VuUHJlY2lzaW9uKTsKCiAgICAgICAgICAvLyBjaGVjayBpZiB0aGUgb3JkZXIgY2FuIHN0aWxsIGJlIGZpbGxlZAogICAgICAgICAgY29uc3QgbmJUb2tlbnNUb0ZpbGxPcmRlciA9IGFwaS5CaWdOdW1iZXIoYnV5T3JkZXIucHJpY2UpCiAgICAgICAgICAgIC5tdWx0aXBsaWVkQnkoYnV5T3JkZXIucXVhbnRpdHkpCiAgICAgICAgICAgIC50b0ZpeGVkKFNURUVNX1BFR0dFRF9TWU1CT0xfUFJFU0lDSU9OKTsKCiAgICAgICAgICBpZiAoYXBpLkJpZ051bWJlcihuYlRva2Vuc1RvRmlsbE9yZGVyKS5sdCgnMC4wMDAwMDAwMScpKSB7CiAgICAgICAgICAgIGF3YWl0IGFwaS50cmFuc2ZlclRva2VucyhhY2NvdW50LCBTVEVFTV9QRUdHRURfU1lNQk9MLCBidXlPcmRlci50b2tlbnNMb2NrZWQsICd1c2VyJyk7CgogICAgICAgICAgICBidXlPcmRlci5xdWFudGl0eSA9ICcwJzsKICAgICAgICAgICAgYXdhaXQgYXBpLmRiLnJlbW92ZSgnYnV5Qm9vaycsIGJ1eU9yZGVyKTsKICAgICAgICAgIH0KCiAgICAgICAgICAvLyBhZGQgdGhlIHRyYWRlIHRvIHRoZSBoaXN0b3J5CiAgICAgICAgICBhd2FpdCB1cGRhdGVUcmFkZXNIaXN0b3J5KCdidXknLCBzeW1ib2wsIHNlbGxPcmRlci5xdWFudGl0eSwgc2VsbE9yZGVyLnByaWNlLCBxdHlUb2tlbnNUb1NlbmQpOwoKICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgdm9sdW1lCiAgICAgICAgICB2b2x1bWVUcmFkZWQgPSBhcGkuQmlnTnVtYmVyKHZvbHVtZVRyYWRlZCkucGx1cyhxdHlUb2tlbnNUb1NlbmQpOwogICAgICAgIH0KICAgICAgfQoKICAgICAgaW5jICs9IDE7CiAgICB9CgogICAgb2Zmc2V0ICs9IDEwMDA7CgogICAgaWYgKGFwaS5CaWdOdW1iZXIoYnV5T3JkZXIucXVhbnRpdHkpLmd0KDApKSB7CiAgICAgIC8vIGdldCB0aGUgb3JkZXJzIHRoYXQgbWF0Y2ggdGhlIHN5bWJvbCBhbmQgdGhlIHByaWNlCiAgICAgIHNlbGxPcmRlckJvb2sgPSBhd2FpdCBhcGkuZGIuZmluZCgnc2VsbEJvb2snLCB7CiAgICAgICAgc3ltYm9sLAogICAgICAgIHByaWNlOiB7CiAgICAgICAgICAkbHRlOiBwcmljZSwKICAgICAgICB9LAogICAgICB9LCAxMDAwLCBvZmZzZXQsCiAgICAgIFsKICAgICAgICB7IGluZGV4OiAncHJpY2UnLCBkZXNjZW5kaW5nOiBmYWxzZSB9LAogICAgICAgIHsgaW5kZXg6ICckbG9raScsIGRlc2NlbmRpbmc6IGZhbHNlIH0sCiAgICAgIF0pOwogICAgfQogIH0gd2hpbGUgKHNlbGxPcmRlckJvb2subGVuZ3RoID4gMCAmJiBhcGkuQmlnTnVtYmVyKGJ1eU9yZGVyLnF1YW50aXR5KS5ndCgwKSk7CgogIC8vIHVwZGF0ZSB0aGUgYnV5IG9yZGVyIGlmIHBhcnRpYWxseSBmaWxsZWQKICBpZiAoYXBpLkJpZ051bWJlcihidXlPcmRlci5xdWFudGl0eSkuZ3QoMCkpIHsKICAgIGF3YWl0IGFwaS5kYi51cGRhdGUoJ2J1eUJvb2snLCBidXlPcmRlcik7CiAgfQogIGlmIChhcGkuQmlnTnVtYmVyKHZvbHVtZVRyYWRlZCkuZ3QoMCkpIHsKICAgIGF3YWl0IHVwZGF0ZVZvbHVtZU1ldHJpYyhzeW1ib2wsIHZvbHVtZVRyYWRlZCk7CiAgfQogIGF3YWl0IHVwZGF0ZUFza01ldHJpYyhzeW1ib2wpOwogIGF3YWl0IHVwZGF0ZUJpZE1ldHJpYyhzeW1ib2wpOwp9OwoKY29uc3QgZmluZE1hdGNoaW5nQnV5T3JkZXJzID0gYXN5bmMgKG9yZGVyLCB0b2tlblByZWNpc2lvbikgPT4gewogIGNvbnN0IHsKICAgIGFjY291bnQsCiAgICBzeW1ib2wsCiAgICBwcmljZSwKICB9ID0gb3JkZXI7CgogIGNvbnN0IHNlbGxPcmRlciA9IG9yZGVyOwogIGxldCBvZmZzZXQgPSAwOwogIGxldCB2b2x1bWVUcmFkZWQgPSAwOwoKICBhd2FpdCByZW1vdmVFeHBpcmVkT3JkZXJzKCdidXlCb29rJyk7CgogIC8vIGdldCB0aGUgb3JkZXJzIHRoYXQgbWF0Y2ggdGhlIHN5bWJvbCBhbmQgdGhlIHByaWNlCiAgbGV0IGJ1eU9yZGVyQm9vayA9IGF3YWl0IGFwaS5kYi5maW5kKCdidXlCb29rJywgewogICAgc3ltYm9sLAogICAgcHJpY2U6IHsKICAgICAgJGd0ZTogcHJpY2UsCiAgICB9LAogIH0sIDEwMDAsIG9mZnNldCwKICBbCiAgICB7IGluZGV4OiAncHJpY2UnLCBkZXNjZW5kaW5nOiB0cnVlIH0sCiAgICB7IGluZGV4OiAnJGxva2knLCBkZXNjZW5kaW5nOiBmYWxzZSB9LAogIF0pOwoKICBkbyB7CiAgICBjb25zdCBuYk9yZGVycyA9IGJ1eU9yZGVyQm9vay5sZW5ndGg7CiAgICBsZXQgaW5jID0gMDsKCiAgICB3aGlsZSAoaW5jIDwgbmJPcmRlcnMgJiYgYXBpLkJpZ051bWJlcihzZWxsT3JkZXIucXVhbnRpdHkpLmd0KDApKSB7CiAgICAgIGNvbnN0IGJ1eU9yZGVyID0gYnV5T3JkZXJCb29rW2luY107CiAgICAgIGlmIChhcGkuQmlnTnVtYmVyKHNlbGxPcmRlci5xdWFudGl0eSkubHRlKGJ1eU9yZGVyLnF1YW50aXR5KSkgewogICAgICAgIGxldCBxdHlUb2tlbnNUb1NlbmQgPSBhcGkuQmlnTnVtYmVyKGJ1eU9yZGVyLnByaWNlKQogICAgICAgICAgLm11bHRpcGxpZWRCeShzZWxsT3JkZXIucXVhbnRpdHkpCiAgICAgICAgICAudG9GaXhlZChTVEVFTV9QRUdHRURfU1lNQk9MX1BSRVNJQ0lPTik7CgogICAgICAgIGlmIChhcGkuQmlnTnVtYmVyKHF0eVRva2Vuc1RvU2VuZCkuZ3QoYnV5T3JkZXIudG9rZW5zTG9ja2VkKSkgewogICAgICAgICAgcXR5VG9rZW5zVG9TZW5kID0gYXBpLkJpZ051bWJlcihidXlPcmRlci5wcmljZSkKICAgICAgICAgICAgLm11bHRpcGxpZWRCeShzZWxsT3JkZXIucXVhbnRpdHkpCiAgICAgICAgICAgIC50b0ZpeGVkKFNURUVNX1BFR0dFRF9TWU1CT0xfUFJFU0lDSU9OLCBhcGkuQmlnTnVtYmVyLlJPVU5EX0RPV04pOwogICAgICAgIH0KCiAgICAgICAgaWYgKGFwaS5hc3NlcnQoYXBpLkJpZ051bWJlcihxdHlUb2tlbnNUb1NlbmQpLmd0KDApCiAgICAgICAgICAmJiBhcGkuQmlnTnVtYmVyKHNlbGxPcmRlci5xdWFudGl0eSkuZ3QoMCksICd0aGUgb3JkZXIgY2Fubm90IGJlIGZpbGxlZCcpKSB7CiAgICAgICAgICAvLyB0cmFuc2ZlciB0aGUgdG9rZW5zIHRvIHRoZSBidXllcgogICAgICAgICAgbGV0IHJlcyA9IGF3YWl0IGFwaS50cmFuc2ZlclRva2VucyhidXlPcmRlci5hY2NvdW50LCBzeW1ib2wsIHNlbGxPcmRlci5xdWFudGl0eSwgJ3VzZXInKTsKCiAgICAgICAgICBpZiAocmVzLmVycm9ycykgewogICAgICAgICAgICBhcGkuZGVidWcocmVzLmVycm9ycyk7CiAgICAgICAgICAgIGFwaS5kZWJ1ZyhgVFhJRDogJHthcGkudHJhbnNhY3Rpb25JZH1gKTsKICAgICAgICAgICAgYXBpLmRlYnVnKGJ1eU9yZGVyLmFjY291bnQpOwogICAgICAgICAgICBhcGkuZGVidWcoc3ltYm9sKTsKICAgICAgICAgICAgYXBpLmRlYnVnKHNlbGxPcmRlci5xdWFudGl0eSk7CiAgICAgICAgICB9CgogICAgICAgICAgLy8gdHJhbnNmZXIgdGhlIHRva2VucyB0byB0aGUgc2VsbGVyCiAgICAgICAgICByZXMgPSBhd2FpdCBhcGkudHJhbnNmZXJUb2tlbnMoYWNjb3VudCwgU1RFRU1fUEVHR0VEX1NZTUJPTCwgcXR5VG9rZW5zVG9TZW5kLCAndXNlcicpOwoKICAgICAgICAgIGlmIChyZXMuZXJyb3JzKSB7CiAgICAgICAgICAgIGFwaS5kZWJ1ZyhyZXMuZXJyb3JzKTsKICAgICAgICAgICAgYXBpLmRlYnVnKGBUWElEOiAke2FwaS50cmFuc2FjdGlvbklkfWApOwogICAgICAgICAgICBhcGkuZGVidWcoYWNjb3VudCk7CiAgICAgICAgICAgIGFwaS5kZWJ1ZyhTVEVFTV9QRUdHRURfU1lNQk9MKTsKICAgICAgICAgICAgYXBpLmRlYnVnKHF0eVRva2Vuc1RvU2VuZCk7CiAgICAgICAgICB9CgogICAgICAgICAgLy8gdXBkYXRlIHRoZSBidXkgb3JkZXIKICAgICAgICAgIGNvbnN0IHF0eUxlZnRCdXlPcmRlciA9IGFwaS5CaWdOdW1iZXIoYnV5T3JkZXIucXVhbnRpdHkpCiAgICAgICAgICAgIC5taW51cyhzZWxsT3JkZXIucXVhbnRpdHkpCiAgICAgICAgICAgIC50b0ZpeGVkKHRva2VuUHJlY2lzaW9uKTsKCiAgICAgICAgICBjb25zdCBidXlPcmRlcnRva2Vuc0xvY2tlZCA9IGFwaS5CaWdOdW1iZXIoYnV5T3JkZXIudG9rZW5zTG9ja2VkKQogICAgICAgICAgICAubWludXMocXR5VG9rZW5zVG9TZW5kKQogICAgICAgICAgICAudG9GaXhlZChTVEVFTV9QRUdHRURfU1lNQk9MX1BSRVNJQ0lPTik7CiAgICAgICAgICBjb25zdCBuYlRva2Vuc1RvRmlsbE9yZGVyID0gYXBpLkJpZ051bWJlcihidXlPcmRlci5wcmljZSkKICAgICAgICAgICAgLm11bHRpcGxpZWRCeShxdHlMZWZ0QnV5T3JkZXIpCiAgICAgICAgICAgIC50b0ZpeGVkKFNURUVNX1BFR0dFRF9TWU1CT0xfUFJFU0lDSU9OKTsKCiAgICAgICAgICBpZiAoYXBpLkJpZ051bWJlcihxdHlMZWZ0QnV5T3JkZXIpLmd0KDApCiAgICAgICAgICAgICYmIChhcGkuQmlnTnVtYmVyKG5iVG9rZW5zVG9GaWxsT3JkZXIpLmd0ZSgnMC4wMDAwMDAwMScpKSkgewogICAgICAgICAgICBidXlPcmRlci5xdWFudGl0eSA9IHF0eUxlZnRCdXlPcmRlcjsKICAgICAgICAgICAgYnV5T3JkZXIudG9rZW5zTG9ja2VkID0gYnV5T3JkZXJ0b2tlbnNMb2NrZWQ7CgogICAgICAgICAgICBhd2FpdCBhcGkuZGIudXBkYXRlKCdidXlCb29rJywgYnV5T3JkZXIpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgaWYgKGFwaS5CaWdOdW1iZXIoYnV5T3JkZXJ0b2tlbnNMb2NrZWQpLmd0KDApKSB7CiAgICAgICAgICAgICAgYXdhaXQgYXBpLnRyYW5zZmVyVG9rZW5zKGJ1eU9yZGVyLmFjY291bnQsIFNURUVNX1BFR0dFRF9TWU1CT0wsIGJ1eU9yZGVydG9rZW5zTG9ja2VkLCAndXNlcicpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGF3YWl0IGFwaS5kYi5yZW1vdmUoJ2J1eUJvb2snLCBidXlPcmRlcik7CiAgICAgICAgICB9CgogICAgICAgICAgLy8gYWRkIHRoZSB0cmFkZSB0byB0aGUgaGlzdG9yeQogICAgICAgICAgYXdhaXQgdXBkYXRlVHJhZGVzSGlzdG9yeSgnc2VsbCcsIHN5bWJvbCwgc2VsbE9yZGVyLnF1YW50aXR5LCBidXlPcmRlci5wcmljZSwgcXR5VG9rZW5zVG9TZW5kKTsKCiAgICAgICAgICAvLyB1cGRhdGUgdGhlIHZvbHVtZQogICAgICAgICAgdm9sdW1lVHJhZGVkID0gYXBpLkJpZ051bWJlcih2b2x1bWVUcmFkZWQpLnBsdXMocXR5VG9rZW5zVG9TZW5kKTsKCiAgICAgICAgICBzZWxsT3JkZXIucXVhbnRpdHkgPSAwOwogICAgICAgICAgYXdhaXQgYXBpLmRiLnJlbW92ZSgnc2VsbEJvb2snLCBzZWxsT3JkZXIpOwogICAgICAgIH0KICAgICAgfSBlbHNlIHsKICAgICAgICBsZXQgcXR5VG9rZW5zVG9TZW5kID0gYXBpLkJpZ051bWJlcihidXlPcmRlci5wcmljZSkKICAgICAgICAgIC5tdWx0aXBsaWVkQnkoYnV5T3JkZXIucXVhbnRpdHkpCiAgICAgICAgICAudG9GaXhlZChTVEVFTV9QRUdHRURfU1lNQk9MX1BSRVNJQ0lPTik7CgogICAgICAgIGlmIChxdHlUb2tlbnNUb1NlbmQgPiBidXlPcmRlci50b2tlbnNMb2NrZWQpIHsKICAgICAgICAgIHF0eVRva2Vuc1RvU2VuZCA9IGFwaS5CaWdOdW1iZXIoYnV5T3JkZXIucHJpY2UpCiAgICAgICAgICAgIC5tdWx0aXBsaWVkQnkoYnV5T3JkZXIucXVhbnRpdHkpCiAgICAgICAgICAgIC50b0ZpeGVkKFNURUVNX1BFR0dFRF9TWU1CT0xfUFJFU0lDSU9OLCBhcGkuQmlnTnVtYmVyLlJPVU5EX0RPV04pOwogICAgICAgIH0KCiAgICAgICAgaWYgKGFwaS5hc3NlcnQoYXBpLkJpZ051bWJlcihxdHlUb2tlbnNUb1NlbmQpLmd0KDApCiAgICAgICAgICAmJiBhcGkuQmlnTnVtYmVyKHNlbGxPcmRlci5xdWFudGl0eSkuZ3QoMCksICd0aGUgb3JkZXIgY2Fubm90IGJlIGZpbGxlZCcpKSB7CiAgICAgICAgICAvLyB0cmFuc2ZlciB0aGUgdG9rZW5zIHRvIHRoZSBidXllcgogICAgICAgICAgbGV0IHJlcyA9IGF3YWl0IGFwaS50cmFuc2ZlclRva2VucyhidXlPcmRlci5hY2NvdW50LCBzeW1ib2wsIGJ1eU9yZGVyLnF1YW50aXR5LCAndXNlcicpOwoKICAgICAgICAgIGlmIChyZXMuZXJyb3JzKSB7CiAgICAgICAgICAgIGFwaS5kZWJ1ZyhyZXMuZXJyb3JzKTsKICAgICAgICAgICAgYXBpLmRlYnVnKGBUWElEOiAke2FwaS50cmFuc2FjdGlvbklkfWApOwogICAgICAgICAgICBhcGkuZGVidWcoYnV5T3JkZXIuYWNjb3VudCk7CiAgICAgICAgICAgIGFwaS5kZWJ1ZyhzeW1ib2wpOwogICAgICAgICAgICBhcGkuZGVidWcoYnV5T3JkZXIucXVhbnRpdHkpOwogICAgICAgICAgfQoKICAgICAgICAgIC8vIHRyYW5zZmVyIHRoZSB0b2tlbnMgdG8gdGhlIHNlbGxlcgogICAgICAgICAgcmVzID0gYXdhaXQgYXBpLnRyYW5zZmVyVG9rZW5zKGFjY291bnQsIFNURUVNX1BFR0dFRF9TWU1CT0wsIHF0eVRva2Vuc1RvU2VuZCwgJ3VzZXInKTsKCiAgICAgICAgICBpZiAocmVzLmVycm9ycykgewogICAgICAgICAgICBhcGkuZGVidWcocmVzLmVycm9ycyk7CiAgICAgICAgICAgIGFwaS5kZWJ1ZyhgVFhJRDogJHthcGkudHJhbnNhY3Rpb25JZH1gKTsKICAgICAgICAgICAgYXBpLmRlYnVnKGFjY291bnQpOwogICAgICAgICAgICBhcGkuZGVidWcoU1RFRU1fUEVHR0VEX1NZTUJPTCk7CiAgICAgICAgICAgIGFwaS5kZWJ1ZyhxdHlUb2tlbnNUb1NlbmQpOwogICAgICAgICAgfQoKICAgICAgICAgIC8vIHJlbW92ZSB0aGUgYnV5IG9yZGVyCiAgICAgICAgICBhd2FpdCBhcGkuZGIucmVtb3ZlKCdidXlCb29rJywgYnV5T3JkZXIpOwoKICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgcXVhbnRpdHkgdG8gZ2V0CiAgICAgICAgICBzZWxsT3JkZXIucXVhbnRpdHkgPSBhcGkuQmlnTnVtYmVyKHNlbGxPcmRlci5xdWFudGl0eSkKICAgICAgICAgICAgLm1pbnVzKGJ1eU9yZGVyLnF1YW50aXR5KQogICAgICAgICAgICAudG9GaXhlZCh0b2tlblByZWNpc2lvbik7CgogICAgICAgICAgLy8gY2hlY2sgaWYgdGhlIG9yZGVyIGNhbiBzdGlsbCBiZSBmaWxsZWQKICAgICAgICAgIGNvbnN0IG5iVG9rZW5zVG9GaWxsT3JkZXIgPSBhcGkuQmlnTnVtYmVyKHNlbGxPcmRlci5wcmljZSkKICAgICAgICAgICAgLm11bHRpcGxpZWRCeShzZWxsT3JkZXIucXVhbnRpdHkpCiAgICAgICAgICAgIC50b0ZpeGVkKFNURUVNX1BFR0dFRF9TWU1CT0xfUFJFU0lDSU9OKTsKCiAgICAgICAgICBpZiAoYXBpLkJpZ051bWJlcihuYlRva2Vuc1RvRmlsbE9yZGVyKS5sdCgnMC4wMDAwMDAwMScpKSB7CiAgICAgICAgICAgIGF3YWl0IGFwaS50cmFuc2ZlclRva2VucyhhY2NvdW50LCBzeW1ib2wsIHNlbGxPcmRlci5xdWFudGl0eSwgJ3VzZXInKTsKCiAgICAgICAgICAgIHNlbGxPcmRlci5xdWFudGl0eSA9ICcwJzsKICAgICAgICAgICAgYXdhaXQgYXBpLmRiLnJlbW92ZSgnc2VsbEJvb2snLCBzZWxsT3JkZXIpOwogICAgICAgICAgfQoKICAgICAgICAgIC8vIGFkZCB0aGUgdHJhZGUgdG8gdGhlIGhpc3RvcnkKICAgICAgICAgIGF3YWl0IHVwZGF0ZVRyYWRlc0hpc3RvcnkoJ3NlbGwnLCBzeW1ib2wsIGJ1eU9yZGVyLnF1YW50aXR5LCBidXlPcmRlci5wcmljZSwgcXR5VG9rZW5zVG9TZW5kKTsKCiAgICAgICAgICAvLyB1cGRhdGUgdGhlIHZvbHVtZQogICAgICAgICAgdm9sdW1lVHJhZGVkID0gYXBpLkJpZ051bWJlcih2b2x1bWVUcmFkZWQpLnBsdXMocXR5VG9rZW5zVG9TZW5kKTsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIGluYyArPSAxOwogICAgfQoKICAgIG9mZnNldCArPSAxMDAwOwoKICAgIGlmIChhcGkuQmlnTnVtYmVyKHNlbGxPcmRlci5xdWFudGl0eSkuZ3QoMCkpIHsKICAgICAgLy8gZ2V0IHRoZSBvcmRlcnMgdGhhdCBtYXRjaCB0aGUgc3ltYm9sIGFuZCB0aGUgcHJpY2UKICAgICAgYnV5T3JkZXJCb29rID0gYXdhaXQgYXBpLmRiLmZpbmQoJ2J1eUJvb2snLCB7CiAgICAgICAgc3ltYm9sLAogICAgICAgIHByaWNlOiB7CiAgICAgICAgICAkZ3RlOiBwcmljZSwKICAgICAgICB9LAogICAgICB9LCAxMDAwLCBvZmZzZXQsCiAgICAgIFsKICAgICAgICB7IGluZGV4OiAncHJpY2UnLCBkZXNjZW5kaW5nOiB0cnVlIH0sCiAgICAgICAgeyBpbmRleDogJyRsb2tpJywgZGVzY2VuZGluZzogZmFsc2UgfSwKICAgICAgXSk7CiAgICB9CiAgfSB3aGlsZSAoYnV5T3JkZXJCb29rLmxlbmd0aCA+IDAgJiYgYXBpLkJpZ051bWJlcihzZWxsT3JkZXIucXVhbnRpdHkpLmd0KDApKTsKCiAgLy8gdXBkYXRlIHRoZSBzZWxsIG9yZGVyIGlmIHBhcnRpYWxseSBmaWxsZWQKICBpZiAoYXBpLkJpZ051bWJlcihzZWxsT3JkZXIucXVhbnRpdHkpLmd0KDApKSB7CiAgICBhd2FpdCBhcGkuZGIudXBkYXRlKCdzZWxsQm9vaycsIHNlbGxPcmRlcik7CiAgfQoKICBpZiAoYXBpLkJpZ051bWJlcih2b2x1bWVUcmFkZWQpLmd0KDApKSB7CiAgICBhd2FpdCB1cGRhdGVWb2x1bWVNZXRyaWMoc3ltYm9sLCB2b2x1bWVUcmFkZWQpOwogIH0KICBhd2FpdCB1cGRhdGVBc2tNZXRyaWMoc3ltYm9sKTsKICBhd2FpdCB1cGRhdGVCaWRNZXRyaWMoc3ltYm9sKTsKfTsKCmNvbnN0IHJlbW92ZUV4cGlyZWRPcmRlcnMgPSBhc3luYyAodGFibGUpID0+IHsKICBjb25zdCB0aW1lc3RhbXBTZWMgPSBhcGkuQmlnTnVtYmVyKG5ldyBEYXRlKGAke2FwaS5zdGVlbUJsb2NrVGltZXN0YW1wfS4wMDBaYCkuZ2V0VGltZSgpKQogICAgLmRpdmlkZWRCeSgxMDAwKQogICAgLnRvTnVtYmVyKCk7CgogIC8vIGNsZWFuIG9yZGVycwogIGxldCBuYk9yZGVyc1RvRGVsZXRlID0gMDsKICBsZXQgb3JkZXJzVG9EZWxldGUgPSBhd2FpdCBhcGkuZGIuZmluZCgKICAgIHRhYmxlLAogICAgewogICAgICBleHBpcmF0aW9uOiB7CiAgICAgICAgJGx0ZTogdGltZXN0YW1wU2VjLAogICAgICB9LAogICAgfSwKICApOwoKICBuYk9yZGVyc1RvRGVsZXRlID0gb3JkZXJzVG9EZWxldGUubGVuZ3RoOwogIHdoaWxlIChuYk9yZGVyc1RvRGVsZXRlID4gMCkgewogICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IG5iT3JkZXJzVG9EZWxldGU7IGluZGV4ICs9IDEpIHsKICAgICAgY29uc3Qgb3JkZXIgPSBvcmRlcnNUb0RlbGV0ZVtpbmRleF07CiAgICAgIGxldCBxdWFudGl0eTsKICAgICAgbGV0IHN5bWJvbDsKCiAgICAgIGlmICh0YWJsZSA9PT0gJ2J1eUJvb2snKSB7CiAgICAgICAgc3ltYm9sID0gU1RFRU1fUEVHR0VEX1NZTUJPTDsKICAgICAgICBxdWFudGl0eSA9IG9yZGVyLnRva2Vuc0xvY2tlZDsKICAgICAgfSBlbHNlIHsKICAgICAgICBzeW1ib2wgPSBvcmRlci5zeW1ib2w7CiAgICAgICAgcXVhbnRpdHkgPSBvcmRlci5xdWFudGl0eTsKICAgICAgfQoKICAgICAgLy8gdW5sb2NrIHRva2VucwogICAgICBhd2FpdCBhcGkudHJhbnNmZXJUb2tlbnMob3JkZXIuYWNjb3VudCwgc3ltYm9sLCBxdWFudGl0eSwgJ3VzZXInKTsKCiAgICAgIGF3YWl0IGFwaS5kYi5yZW1vdmUodGFibGUsIG9yZGVyKTsKCiAgICAgIGlmICh0YWJsZSA9PT0gJ2J1eUJvb2snKSB7CiAgICAgICAgYXdhaXQgdXBkYXRlQXNrTWV0cmljKG9yZGVyLnN5bWJvbCk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgYXdhaXQgdXBkYXRlQmlkTWV0cmljKG9yZGVyLnN5bWJvbCk7CiAgICAgIH0KICAgIH0KCiAgICBvcmRlcnNUb0RlbGV0ZSA9IGF3YWl0IGFwaS5kYi5maW5kKAogICAgICB0YWJsZSwKICAgICAgewogICAgICAgIGV4cGlyYXRpb246IHsKICAgICAgICAgICRsdGU6IHRpbWVzdGFtcFNlYywKICAgICAgICB9LAogICAgICB9LAogICAgKTsKCiAgICBuYk9yZGVyc1RvRGVsZXRlID0gb3JkZXJzVG9EZWxldGUubGVuZ3RoOwogIH0KfTsKCmNvbnN0IGdldE1ldHJpYyA9IGFzeW5jIChzeW1ib2wpID0+IHsKICBsZXQgbWV0cmljID0gYXdhaXQgYXBpLmRiLmZpbmRPbmUoJ21ldHJpY3MnLCB7IHN5bWJvbCB9KTsKCiAgaWYgKG1ldHJpYyA9PT0gbnVsbCkgewogICAgbWV0cmljID0ge307CiAgICBtZXRyaWMuc3ltYm9sID0gc3ltYm9sOwogICAgbWV0cmljLnZvbHVtZSA9ICcwJzsKICAgIG1ldHJpYy52b2x1bWVFeHBpcmF0aW9uID0gMDsKICAgIG1ldHJpYy5sYXN0UHJpY2UgPSAnMCc7CiAgICBtZXRyaWMubG93ZXN0QXNrID0gJzAnOwogICAgbWV0cmljLmhpZ2hlc3RCaWQgPSAnMCc7CiAgICBtZXRyaWMubGFzdERheVByaWNlID0gJzAnOwogICAgbWV0cmljLmxhc3REYXlQcmljZUV4cGlyYXRpb24gPSAwOwogICAgbWV0cmljLnByaWNlQ2hhbmdlU3RlZW0gPSAnMCc7CiAgICBtZXRyaWMucHJpY2VDaGFuZ2VQZXJjZW50ID0gJzAnOwoKICAgIGNvbnN0IG5ld01ldHJpYyA9IGF3YWl0IGFwaS5kYi5pbnNlcnQoJ21ldHJpY3MnLCBtZXRyaWMpOwogICAgcmV0dXJuIG5ld01ldHJpYzsKICB9CgogIHJldHVybiBtZXRyaWM7Cn07Cgpjb25zdCB1cGRhdGVWb2x1bWVNZXRyaWMgPSBhc3luYyAoc3ltYm9sLCBxdWFudGl0eSwgYWRkID0gdHJ1ZSkgPT4gewogIGNvbnN0IGJsb2NrRGF0ZSA9IG5ldyBEYXRlKGAke2FwaS5zdGVlbUJsb2NrVGltZXN0YW1wfS4wMDBaYCk7CiAgY29uc3QgdGltZXN0YW1wU2VjID0gYmxvY2tEYXRlLmdldFRpbWUoKSAvIDEwMDA7CiAgY29uc3QgbWV0cmljID0gYXdhaXQgZ2V0TWV0cmljKHN5bWJvbCk7CgogIGlmIChhZGQgPT09IHRydWUpIHsKICAgIGlmIChtZXRyaWMudm9sdW1lRXhwaXJhdGlvbiA8IHRpbWVzdGFtcFNlYykgewogICAgICBtZXRyaWMudm9sdW1lID0gJzAuMDAwJzsKICAgIH0KICAgIG1ldHJpYy52b2x1bWUgPSBhcGkuQmlnTnVtYmVyKG1ldHJpYy52b2x1bWUpCiAgICAgIC5wbHVzKHF1YW50aXR5KQogICAgICAudG9GaXhlZChTVEVFTV9QRUdHRURfU1lNQk9MX1BSRVNJQ0lPTik7CiAgICBtZXRyaWMudm9sdW1lRXhwaXJhdGlvbiA9IGJsb2NrRGF0ZS5zZXREYXRlKGJsb2NrRGF0ZS5nZXREYXRlKCkgKyAxKSAvIDEwMDA7CiAgfSBlbHNlIHsKICAgIG1ldHJpYy52b2x1bWUgPSBhcGkuQmlnTnVtYmVyKG1ldHJpYy52b2x1bWUpCiAgICAgIC5taW51cyhxdWFudGl0eSkKICAgICAgLnRvRml4ZWQoU1RFRU1fUEVHR0VEX1NZTUJPTF9QUkVTSUNJT04pOwogIH0KCiAgaWYgKGFwaS5CaWdOdW1iZXIobWV0cmljLnZvbHVtZSkubHQoMCkpIHsKICAgIG1ldHJpYy52b2x1bWUgPSAnMC4wMDAnOwogIH0KCiAgYXdhaXQgYXBpLmRiLnVwZGF0ZSgnbWV0cmljcycsIG1ldHJpYyk7Cn07Cgpjb25zdCB1cGRhdGVQcmljZU1ldHJpY3MgPSBhc3luYyAoc3ltYm9sLCBwcmljZSkgPT4gewogIGNvbnN0IGJsb2NrRGF0ZSA9IG5ldyBEYXRlKGAke2FwaS5zdGVlbUJsb2NrVGltZXN0YW1wfS4wMDBaYCk7CiAgY29uc3QgdGltZXN0YW1wU2VjID0gYmxvY2tEYXRlLmdldFRpbWUoKSAvIDEwMDA7CgogIGNvbnN0IG1ldHJpYyA9IGF3YWl0IGdldE1ldHJpYyhzeW1ib2wpOwoKICBtZXRyaWMubGFzdFByaWNlID0gcHJpY2U7CgogIGlmIChtZXRyaWMubGFzdERheVByaWNlRXhwaXJhdGlvbiA8IHRpbWVzdGFtcFNlYykgewogICAgbWV0cmljLmxhc3REYXlQcmljZSA9IHByaWNlOwogICAgbWV0cmljLmxhc3REYXlQcmljZUV4cGlyYXRpb24gPSBibG9ja0RhdGUuc2V0RGF0ZShibG9ja0RhdGUuZ2V0RGF0ZSgpICsgMSkgLyAxMDAwOwogICAgbWV0cmljLnByaWNlQ2hhbmdlU3RlZW0gPSAnMCc7CiAgICBtZXRyaWMucHJpY2VDaGFuZ2VQZXJjZW50ID0gJzAlJzsKICB9IGVsc2UgewogICAgbWV0cmljLnByaWNlQ2hhbmdlU3RlZW0gPSBhcGkuQmlnTnVtYmVyKHByaWNlKQogICAgICAubWludXMobWV0cmljLmxhc3REYXlQcmljZSkKICAgICAgLnRvRml4ZWQoU1RFRU1fUEVHR0VEX1NZTUJPTF9QUkVTSUNJT04pOwogICAgbWV0cmljLnByaWNlQ2hhbmdlUGVyY2VudCA9IGAke2FwaS5CaWdOdW1iZXIobWV0cmljLnByaWNlQ2hhbmdlU3RlZW0pLmRpdmlkZWRCeShtZXRyaWMubGFzdERheVByaWNlKS5tdWx0aXBsaWVkQnkoMTAwKS50b0ZpeGVkKDIpfSVgOwogIH0KCiAgYXdhaXQgYXBpLmRiLnVwZGF0ZSgnbWV0cmljcycsIG1ldHJpYyk7Cn07Cgpjb25zdCB1cGRhdGVCaWRNZXRyaWMgPSBhc3luYyAoc3ltYm9sKSA9PiB7CiAgY29uc3QgbWV0cmljID0gYXdhaXQgZ2V0TWV0cmljKHN5bWJvbCk7CgogIGNvbnN0IGJ1eU9yZGVyQm9vayA9IGF3YWl0IGFwaS5kYi5maW5kKCdidXlCb29rJywKICAgIHsKICAgICAgc3ltYm9sLAogICAgfSwgMSwgMCwKICAgIFsKICAgICAgeyBpbmRleDogJ3ByaWNlJywgZGVzY2VuZGluZzogdHJ1ZSB9LAogICAgXSk7CgoKICBpZiAoYnV5T3JkZXJCb29rLmxlbmd0aCA+IDApIHsKICAgIG1ldHJpYy5oaWdoZXN0QmlkID0gYnV5T3JkZXJCb29rWzBdLnByaWNlOwogIH0gZWxzZSB7CiAgICBtZXRyaWMuaGlnaGVzdEJpZCA9ICcwJzsKICB9CgogIGF3YWl0IGFwaS5kYi51cGRhdGUoJ21ldHJpY3MnLCBtZXRyaWMpOwp9OwoKY29uc3QgdXBkYXRlQXNrTWV0cmljID0gYXN5bmMgKHN5bWJvbCkgPT4gewogIGNvbnN0IG1ldHJpYyA9IGF3YWl0IGdldE1ldHJpYyhzeW1ib2wpOwoKICBjb25zdCBzZWxsT3JkZXJCb29rID0gYXdhaXQgYXBpLmRiLmZpbmQoJ3NlbGxCb29rJywKICAgIHsKICAgICAgc3ltYm9sLAogICAgfSwgMSwgMCwKICAgIFsKICAgICAgeyBpbmRleDogJ3ByaWNlJywgZGVzY2VuZGluZzogZmFsc2UgfSwKICAgIF0pOwoKICBpZiAoc2VsbE9yZGVyQm9vay5sZW5ndGggPiAwKSB7CiAgICBtZXRyaWMubG93ZXN0QXNrID0gc2VsbE9yZGVyQm9va1swXS5wcmljZTsKICB9IGVsc2UgewogICAgbWV0cmljLmxvd2VzdEFzayA9ICcwJzsKICB9CgogIGF3YWl0IGFwaS5kYi51cGRhdGUoJ21ldHJpY3MnLCBtZXRyaWMpOwp9OwoKY29uc3QgdXBkYXRlVHJhZGVzSGlzdG9yeSA9IGFzeW5jICh0eXBlLCBzeW1ib2wsIHF1YW50aXR5LCBwcmljZSwgdm9sdW1lKSA9PiB7CiAgY29uc3QgYmxvY2tEYXRlID0gbmV3IERhdGUoYCR7YXBpLnN0ZWVtQmxvY2tUaW1lc3RhbXB9LjAwMFpgKTsKICBjb25zdCB0aW1lc3RhbXBTZWMgPSBibG9ja0RhdGUuZ2V0VGltZSgpIC8gMTAwMDsKICBjb25zdCB0aW1lc3RhbXBNaW51czI0aHJzID0gYmxvY2tEYXRlLnNldERhdGUoYmxvY2tEYXRlLmdldERhdGUoKSAtIDEpIC8gMTAwMDsKICAvLyBjbGVhbiBoaXN0b3J5CgogIGxldCB0cmFkZXNUb0RlbGV0ZSA9IGF3YWl0IGFwaS5kYi5maW5kKAogICAgJ3RyYWRlc0hpc3RvcnknLAogICAgewogICAgICBzeW1ib2wsCiAgICAgIHRpbWVzdGFtcDogewogICAgICAgICRsdDogdGltZXN0YW1wTWludXMyNGhycywKICAgICAgfSwKICAgIH0sCiAgKTsKICBsZXQgbmJUcmFkZXNUb0RlbGV0ZSA9IHRyYWRlc1RvRGVsZXRlLmxlbmd0aDsKCiAgd2hpbGUgKG5iVHJhZGVzVG9EZWxldGUgPiAwKSB7CiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgbmJUcmFkZXNUb0RlbGV0ZTsgaW5kZXggKz0gMSkgewogICAgICBjb25zdCB0cmFkZSA9IHRyYWRlc1RvRGVsZXRlW2luZGV4XTsKICAgICAgYXdhaXQgdXBkYXRlVm9sdW1lTWV0cmljKHRyYWRlLnN5bWJvbCwgdHJhZGUudm9sdW1lLCBmYWxzZSk7CiAgICAgIGF3YWl0IGFwaS5kYi5yZW1vdmUoJ3RyYWRlc0hpc3RvcnknLCB0cmFkZSk7CiAgICB9CiAgICB0cmFkZXNUb0RlbGV0ZSA9IGF3YWl0IGFwaS5kYi5maW5kKAogICAgICAndHJhZGVzSGlzdG9yeScsCiAgICAgIHsKICAgICAgICBzeW1ib2wsCiAgICAgICAgdGltZXN0YW1wOiB7CiAgICAgICAgICAkbHQ6IHRpbWVzdGFtcE1pbnVzMjRocnMsCiAgICAgICAgfSwKICAgICAgfSwKICAgICk7CiAgICBuYlRyYWRlc1RvRGVsZXRlID0gdHJhZGVzVG9EZWxldGUubGVuZ3RoOwogIH0KICAvLyBhZGQgb3JkZXIgdG8gdGhlIGhpc3RvcnkKICBjb25zdCBuZXdUcmFkZSA9IHt9OwogIG5ld1RyYWRlLnR5cGUgPSB0eXBlOwogIG5ld1RyYWRlLnN5bWJvbCA9IHN5bWJvbDsKICBuZXdUcmFkZS5xdWFudGl0eSA9IHF1YW50aXR5OwogIG5ld1RyYWRlLnByaWNlID0gcHJpY2U7CiAgbmV3VHJhZGUudGltZXN0YW1wID0gdGltZXN0YW1wU2VjOwogIG5ld1RyYWRlLnZvbHVtZSA9IHZvbHVtZTsKICBhd2FpdCBhcGkuZGIuaW5zZXJ0KCd0cmFkZXNIaXN0b3J5JywgbmV3VHJhZGUpOwogIGF3YWl0IHVwZGF0ZVByaWNlTWV0cmljcyhzeW1ib2wsIHByaWNlKTsKfTsKCmNvbnN0IGNvdW50RGVjaW1hbHMgPSB2YWx1ZSA9PiBhcGkuQmlnTnVtYmVyKHZhbHVlKS5kcCgpOwo='
        }

        // the code of the smart contarct comes as a Base64 encoded string
        codeTemplate = codeTemplate.replace('###ACTIONS###', Base64.decode(finalCode));

        // compile the code for faster executions later on
        const script = new VMScript(codeTemplate).compile();

        const tables = {};

        // prepare the db object that will be available in the VM
        const db = {
          // createTable is only available during the smart contract deployment
          createTable: (tableName, indexes = []) => SmartContracts.createTable(
            ipc, tables, name, tableName, indexes,
          ),
          // perform a query find on a table of the smart contract
          find: (table, query, limit = 1000, offset = 0, indexes = []) => SmartContracts.find(
            ipc, name, table, query, limit, offset, indexes,
          ),
          // perform a query find on a table of an other smart contract
          findInTable: (contractName, table, query, limit = 1000, offset = 0, index = '', descending = false) => SmartContracts.find(
            ipc, contractName, table, query, limit, offset, index, descending,
          ),
          // perform a query findOne on a table of the smart contract
          findOne: (table, query) => SmartContracts.findOne(ipc, name, table, query),
          // perform a query findOne on a table of an other smart contract
          findOneInTable: (contractName, table, query) => SmartContracts.findOne(
            ipc, contractName, table, query,
          ),
          // find the information of a contract
          findContract: contractName => SmartContracts.findContract(ipc, contractName),
          // insert a record in the table of the smart contract
          insert: (table, record) => SmartContracts.dinsert(ipc, name, table, record),
          // insert a record in the table of the smart contract
          remove: (table, record) => SmartContracts.remove(ipc, name, table, record),
          // insert a record in the table of the smart contract
          update: (table, record) => SmartContracts.update(ipc, name, table, record),
          // check if a table exists
          tableExists: table => SmartContracts.tableExists(ipc, name, table),
        };

        // logs used to store events or errors
        const logs = {
          errors: [],
          events: [],
        };

        const rng = seedrandom(`${prevRefSteemBlockId}${refSteemBlockId}${transactionId}`);

        // initialize the state that will be available in the VM
        const vmState = {
          api: {
            action: 'createSSC',
            payload: params ? JSON.parse(JSON.stringify(params)) : null,
            transactionId,
            blockNumber,
            refSteemBlockNumber,
            steemBlockTimestamp: timestamp,
            db,
            BigNumber,
            validator,
            random: () => rng(),
            debug: log => console.log(log), // eslint-disable-line no-console
            // execute a smart contract from the current smart contract
            executeSmartContract: async (
              contractName, actionName, parameters,
            ) => SmartContracts.executeSmartContractFromSmartContract(
              ipc, logs, finalSender, params, contractName, actionName,
              JSON.stringify(parameters),
              blockNumber, timestamp,
              refSteemBlockNumber, refSteemBlockId, prevRefSteemBlockId, jsVMTimeout,
            ),
            // emit an event that will be stored in the logs
            emit: (event, data) => typeof event === 'string' && logs.events.push({ contract: name, event, data }),
            // add an error that will be stored in the logs
            assert: (condition, error) => {
              if (!condition && typeof error === 'string') {
                logs.errors.push(error);
              }
              return condition;
            },
          },
        };

        const error = await SmartContracts.runContractCode(vmState, script, jsVMTimeout);
        if (error) {
          if (error.name && typeof error.name === 'string'
            && error.message && typeof error.message === 'string') {
            return { errors: [`${error.name}: ${error.message}`] };
          }

          return { logs: { errors: ['unknown error'] } };
        }

        const newContract = {
          _id: name,
          owner: finalSender,
          code: codeTemplate,
          codeHash: SHA256(codeTemplate).toString(enchex),
          tables,
        };

        // if contract already exists, update it
        if (existingContract !== null) {
          newContract._id = existingContract._id; // eslint-disable-line no-underscore-dangle
          newContract.tables = Object.assign(existingContract.tables, newContract.tables);

          await ipc.send(
            {
              to: DB_PLUGIN_NAME,
              action: DB_PLUGIN_ACTIONS.UPDATE_CONTRACT,
              payload: newContract,
            },
          );
        } else {
          await ipc.send(
            { to: DB_PLUGIN_NAME, action: DB_PLUGIN_ACTIONS.ADD_CONTRACT, payload: newContract },
          );
        }
        return { executedCodeHash: newContract.codeHash, logs };
      }
      return { logs: { errors: ['parameters name and code are mandatory and they must be strings'] } };
    } catch (e) {
      // console.error('ERROR DURING CONTRACT DEPLOYMENT: ', e);
      return { logs: { errors: [`${e.name}: ${e.message}`] } };
    }
  }

  // execute the smart contract and perform actions on the database if needed
  static async executeSmartContract(
    ipc, transaction, blockNumber, timestamp, refSteemBlockId, prevRefSteemBlockId, jsVMTimeout,
  ) {
    try {
      const {
        transactionId,
        sender,
        contract,
        action,
        payload,
        refSteemBlockNumber,
      } = transaction;

      if (RESERVED_ACTIONS.includes(action)) return { logs: { errors: ['you cannot trigger this action'] } };

      const payloadObj = payload ? JSON.parse(payload) : {};

      const res = await ipc.send(
        {
          to: DB_PLUGIN_NAME,
          action: DB_PLUGIN_ACTIONS.FIND_CONTRACT,
          payload: { name: contract },
        },
      );

      const contractInDb = res.payload;
      if (contractInDb === null) {
        return { logs: { errors: ['contract doesn\'t exist'] } };
      }

      const contractCode = contractInDb.code;
      const contractOwner = contractInDb.owner;

      // prepare the db object that will be available in the VM
      const db = {
        // perform a query find on a table of the smart contract
        find: (table, query, limit = 1000, offset = 0, indexes = []) => SmartContracts.find(
          ipc, contract, table, query, limit, offset, indexes,
        ),
        // perform a query find on a table of an other smart contract
        findInTable: (contractName, table, query, limit = 1000, offset = 0, index = '', descending = false) => SmartContracts.find(
          ipc, contractName, table, query, limit, offset, index, descending,
        ),
        // perform a query findOne on a table of the smart contract
        findOne: (table, query) => SmartContracts.findOne(ipc, contract, table, query),
        // perform a query findOne on a table of an other smart contract
        findOneInTable: (contractName, table, query) => SmartContracts.findOne(
          ipc, contractName, table, query,
        ),
        // find the information of a contract
        findContract: contractName => SmartContracts.findContract(ipc, contractName),
        // insert a record in the table of the smart contract
        insert: (table, record) => SmartContracts.insert(ipc, contract, table, record),
        // insert a record in the table of the smart contract
        remove: (table, record) => SmartContracts.remove(ipc, contract, table, record),
        // insert a record in the table of the smart contract
        update: (table, record) => SmartContracts.update(ipc, contract, table, record),
      };

      // logs used to store events or errors
      const results = {
        executedCodeHash: contractInDb.codeHash,
        logs: {
          errors: [],
          events: [],
        },
      };

      const rng = seedrandom(`${prevRefSteemBlockId}${refSteemBlockId}${transactionId}`);

      // initialize the state that will be available in the VM
      const vmState = {
        api: {
          sender,
          owner: contractOwner,
          refSteemBlockNumber,
          steemBlockTimestamp: timestamp,
          transactionId,
          blockNumber,
          action,
          payload: JSON.parse(JSON.stringify(payloadObj)),
          db,
          BigNumber,
          validator,
          random: () => rng(),
          debug: log => console.log(log), // eslint-disable-line no-console
          // execute a smart contract from the current smart contract
          executeSmartContract: async (
            contractName, actionName, parameters,
          ) => SmartContracts.executeSmartContractFromSmartContract(
            ipc, results, sender, payloadObj, contractName, actionName,
            JSON.stringify(parameters),
            blockNumber, timestamp,
            refSteemBlockNumber, refSteemBlockId, prevRefSteemBlockId, jsVMTimeout,
          ),
          // execute a smart contract from the current smart contract
          // with the contractOwner authority level
          executeSmartContractAsOwner: async (
            contractName, actionName, parameters,
          ) => SmartContracts.executeSmartContractFromSmartContract(
            ipc, results, contractOwner, payloadObj, contractName, actionName,
            JSON.stringify(parameters),
            blockNumber, timestamp,
            refSteemBlockNumber, refSteemBlockId, prevRefSteemBlockId, jsVMTimeout,
          ),
          // execute a token transfer from the contract balance
          transferTokens: async (
            to, symbol, quantity, type,
          ) => SmartContracts.executeSmartContractFromSmartContract(
            ipc, results, 'null', payloadObj, 'tokens', 'transferFromContract',
            JSON.stringify({
              from: contract,
              to,
              quantity,
              symbol,
              type,
            }),
            blockNumber, timestamp,
            refSteemBlockNumber, refSteemBlockId, prevRefSteemBlockId, jsVMTimeout,
          ),
          // emit an event that will be stored in the logs
          emit: (event, data) => typeof event === 'string' && results.logs.events.push({ contract, event, data }),
          // add an error that will be stored in the logs
          assert: (condition, error) => {
            if (!condition && typeof error === 'string') {
              results.logs.errors.push(error);
            }
            return condition;
          },
        },
      };

      const error = await SmartContracts.runContractCode(vmState, contractCode, jsVMTimeout);

      if (error) {
        const { name, message } = error;
        if (name && typeof name === 'string'
          && message && typeof message === 'string') {
          return { logs: { errors: [`${name}: ${message}`] } };
        }

        return { logs: { errors: ['unknown error'] } };
      }

      return results;
    } catch (e) {
      // console.error('ERROR DURING CONTRACT EXECUTION: ', e);
      return { logs: { errors: [`${e.name}: ${e.message}`] } };
    }
  }

  // run the contractCode in a VM with the vmState as a state for the VM
  static runContractCode(vmState, contractCode, jsVMTimeout) {
    return new Promise((resolve) => {
      try {
        // console.log('vmState', vmState)
        // run the code in the VM
        const vm = new VM({
          timeout: jsVMTimeout,
          sandbox: {
            ...vmState,
            done: (error) => {
              // console.log('error', error);
              resolve(error);
            },
          },
        });

        vm.run(contractCode);
      } catch (err) {
        resolve(err);
      }
    });
  }

  static async executeSmartContractFromSmartContract(
    ipc, originalResults, sender, originalParameters,
    contract, action, parameters,
    blockNumber,
    timestamp,
    refSteemBlockNumber, refSteemBlockId, prevRefSteemBlockId,
    jsVMTimeout,
  ) {
    if (typeof contract !== 'string' || typeof action !== 'string' || (parameters && typeof parameters !== 'string')) return null;
    const sanitizedParams = parameters ? JSON.parse(parameters) : null;

    // check if a recipient or amountSTEEMSBD
    //  or isSignedWithActiveKey  were passed initially
    if (originalParameters && originalParameters.amountSTEEMSBD) {
      sanitizedParams.amountSTEEMSBD = originalParameters.amountSTEEMSBD;
    }

    if (originalParameters && originalParameters.recipient) {
      sanitizedParams.recipient = originalParameters.recipient;
    }

    if (originalParameters && originalParameters.isSignedWithActiveKey) {
      sanitizedParams.isSignedWithActiveKey = originalParameters.isSignedWithActiveKey;
    }

    const results = {};
    try {
      const res = await SmartContracts.executeSmartContract(
        ipc,
        {
          sender,
          contract,
          action,
          payload: JSON.stringify(sanitizedParams),
          refSteemBlockNumber,
        },
        blockNumber,
        timestamp,
        refSteemBlockId,
        prevRefSteemBlockId,
        jsVMTimeout,
      );

      if (res && res.logs && res.logs.errors !== undefined) {
        res.logs.errors.forEach((error) => {
          if (results.errors === undefined) {
            results.errors = [];
          }
          if (originalResults.logs.errors === undefined) {
            originalResults.logs.errors = []; // eslint-disable-line no-param-reassign
          }

          originalResults.logs.errors.push(error);
          results.errors.push(error);
        });
      }

      if (res && res.logs && res.logs.events !== undefined) {
        res.logs.events.forEach((event) => {
          if (results.events === undefined) {
            results.events = [];
          }
          if (originalResults.logs.events === undefined) {
            originalResults.logs.events = []; // eslint-disable-line no-param-reassign
          }

          originalResults.logs.events.push(event);
          results.events.push(event);
        });
      }

      if (res && res.executedCodeHash) {
        results.executedCodeHash = res.executedCodeHash;
        originalResults.executedCodeHash += res.executedCodeHash; // eslint-disable-line
      }
    } catch (error) {
      results.errors = [];
      results.errors.push(error);
    }
    return results;
  }

  static async createTable(ipc, tables, contractName, tableName, indexes = []) {
    const res = await ipc.send({
      to: DB_PLUGIN_NAME,
      action: DB_PLUGIN_ACTIONS.CREATE_TABLE,
      payload: {
        contractName,
        tableName,
        indexes,
      },
    });

    if (res.payload === true) {
      // add the table name to the list of table available for this contract
      const finalTableName = `${contractName}_${tableName}`;
      if (tables[finalTableName] === undefined) {
        tables[finalTableName] = { // eslint-disable-line
          size: 0,
          hash: '',
          nbIndexes: indexes.length,
        };
      }
    }
  }

  static async find(ipc, contractName, table, query, limit = 1000, offset = 0, indexes = []) {
    const res = await ipc.send({
      to: DB_PLUGIN_NAME,
      action: DB_PLUGIN_ACTIONS.FIND,
      payload: {
        contract: contractName,
        table,
        query,
        limit,
        offset,
        indexes,
      },
    });

    return res.payload;
  }

  static async findOne(ipc, contractName, table, query) {
    const res = await ipc.send({
      to: DB_PLUGIN_NAME,
      action: DB_PLUGIN_ACTIONS.FIND_ONE,
      payload: {
        contract: contractName,
        table,
        query,
      },
    });

    return res.payload;
  }

  static async findContract(ipc, contractName) {
    const res = await ipc.send({
      to: DB_PLUGIN_NAME,
      action: DB_PLUGIN_ACTIONS.FIND_CONTRACT,
      payload: {
        name: contractName,
      },
    });

    return res.payload;
  }

  static async insert(ipc, contractName, table, record) {
    const res = await ipc.send({
      to: DB_PLUGIN_NAME,
      action: DB_PLUGIN_ACTIONS.INSERT,
      payload: {
        contract: contractName,
        table,
        record,
      },
    });

    return res.payload;
  }

  static async dinsert(ipc, contractName, table, record) {
    const res = await ipc.send({
      to: DB_PLUGIN_NAME,
      action: DB_PLUGIN_ACTIONS.DINSERT,
      payload: {
        table: `${contractName}_${table}`,
        record,
      },
    });

    return res.payload;
  }

  static async remove(ipc, contractName, table, record) {
    const res = await ipc.send({
      to: DB_PLUGIN_NAME,
      action: DB_PLUGIN_ACTIONS.REMOVE,
      payload: {
        contract: contractName,
        table,
        record,
      },
    });

    return res.payload;
  }

  static async update(ipc, contractName, table, record) {
    const res = await ipc.send({
      to: DB_PLUGIN_NAME,
      action: DB_PLUGIN_ACTIONS.UPDATE,
      payload: {
        contract: contractName,
        table,
        record,
      },
    });

    return res.payload;
  }

  static async tableExists(ipc, contractName, table) {
    const res = await ipc.send({
      to: DB_PLUGIN_NAME,
      action: DB_PLUGIN_ACTIONS.TABLE_EXISTS,
      payload: {
        contract: contractName,
        table,
      },
    });

    return res.payload;
  }
}

module.exports.SmartContracts = SmartContracts;
